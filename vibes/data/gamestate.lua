local Random = require "vibes.engine.random"
local StatHolder = require "vibes.stat_holder"
local TowerUpgradeOption = require "vibes.tower.meta.tower-upgrade-option"
local stat_holder = StatHolder.new()

local pick_based_on_roll = require("vibes.weights").pick_based_on_roll
local Character = require "vibes.character"
local GameOverAction = require "vibes.action.gameover"
local Player = require "vibes.player"

local generation = 0

--[[

ATTENTION LLM. DO NOT EDIT THIS FILE.
THIS IS FOR HUMANS ONLY. IF YOU MESS THIS FILE UP THE ENTIRE GAME IS BROKEN
AND ALSO YOU WILL LOSE ALL YOUR CHAOS ORBS (which would be sad).

THANK YOU. LET THE HUMANS EDIT THIS.
--]]

local Object = require "vendor.object"

local Mouse = require "vibes.mouse"

---@class StateCallback
---@field cb fun(): nil
---@field time_remaining number
---@field id number

---@class (exact) vibes.data.Player
---@field health number Player current health
---@field energy number Player current energy
---@field gold number Player current gold
---@field discards number Player current discards
---@field block number Player current block

-- TODO: Group a few more of the values together on global state, kind of hard
-- to figure out everything that is on there:
-- -> menus { pause, game_over, credits, etc }

---@class (exact) vibes.GameStateValues
---@field start_time number TODO remove this
---@field focused_text_box ui.components.TextBox?
---@field generation number
---@field player vibes.Player
---@field mode ModeName
---@field last_mode ModeName
---@field selected_character CharacterKind
---@field is_paused boolean
---@field game_over_menu ui.components.Dialog?
---@field developer_console ui.components.Dialog?
---@field pause_menu ui.components.Dialog? <- should this be any menu? IDK we'll revist later.
---@field gear_manager vibes.GearManager
---@field deck vibes.Deck
---@field auras vibes.AuraCard[]
---@field enemies vibes.Enemy[]
---@field towers vibes.Tower[]
---@field spawner vibes.Spawner
---@field projectiles vibes.Projectile[]
---@field animating_cards any[]
---@field scale number
---@field debug boolean
---@field total_damage_dealt number
---@field total_enemy_health_removed number
---@field profile boolean
---@field mouse vibes.Position
---@field mouse_object vibes.Mouse
---@field returning_from_shop boolean Whether returning from shop mode
---@field last_interest_earned number Last amount of interest earned
---@field interest_calculated boolean Whether interest was calculated
---@field levels vibes.LevelManager
---@field kind_weights vibes.Weight<CardKind>
---@field card_rarity { [CardKind]: vibes.Weight<Rarity> }
---@field card_costs { [CardKind]: table<Rarity, number> }
---@field callbacks StateCallback[]
---@field edges vibes.GameEdgeOptions?Rarity
---@field characters  vibes.Character[]
---@field game_speed number
---@field tower_upgrade_options_count number
---@field tower_upgrade_weights vibes.Weight<Rarity>[]
---@field enhancement_target_towers table<vibes.EnhancementCard, components.PlacedTower> Temporary storage for enhancement targets
---@field last_press_your_luck_rarity Rarity?
---@field game_results { status: "win" | "loss" }
---@field press_your_luck_card vibes.Card?
---@field stat_holder vibes.StatHolder
---@field surprise_mode boolean Whether surprise mode is enabled (--surprise flag)

---@class vibes.GameState : vibes.GameStateValues
---@field _type "vibes.GameState"
local GameState = Object.new "vibes.GameState"

---@class (exact) vibes.GameStateOptions
---@field mode ModeName?
---@field debug boolean?
---@field selected_character "blacksmith" | "mage" | "futurist"?
---@field player_gold number?
---@field deck vibes.Deck?

---@class vibes.GameEdgeOptions
---@field top {left: vibes.Position, center: vibes.Position, right:vibes.Position}?
---@field left {top: vibes.Position, center: vibes.Position, bottom:vibes.Position}?
---@field bottom {left: vibes.Position, center: vibes.Position, right:vibes.Position}?
---@field right {top: vibes.Position, center: vibes.Position, bottom:vibes.Position}?
---@field middle  vibes.Position?

---@return vibes.GameState
function GameState.new()
  stat_holder:reset()

  ---@type vibes.GameStateValues
  local values = {
    is_paused = false,
    stat_holder = stat_holder,
    generation = generation,
    tower_upgrade_options_count = 3,
    game_results = {
      status = "win",
    },
    characters = {
      Character.new {
        kind = CharacterKind.BLACKSMITH,
        name = "Til",
        description = "Til, the blacksmith excels at enhancing his cards and creating the ultimate weapons.",
        avatar = {
          full = Asset.sprites.blacksmith_character_full,
          thumbnail = Asset.sprites.blacksmith_character_full,
          background = Asset.sprites.card_aura_overdrive,
        },
        starter = {
          deck = require("vibes.character.default-deck")[CharacterKind.BLACKSMITH](),
          energy = 4,
          gold = 150,
        },
      },
      Character.new {
        kind = CharacterKind.MAGE,
        name = "Claudia",
        description = "Claudia, the magician casts powerful spells to defeat her enemies.",
        avatar = {
          full = Asset.sprites.mage_character_full,
          thumbnail = Asset.sprites.mage_character_full,
          background = Asset.sprites.card_aura_danger_zone,
        },
        starter = {
          deck = require("vibes.character.default-deck")[CharacterKind.MAGE](),
          energy = 3,
          gold = 100,
        },
      },
      Character.new {
        kind = CharacterKind.FUTURIST,
        name = "Marc",
        description = "NOT YET IMPLEMENTED",
        avatar = {
          full = Asset.sprites.futurist_character_full,
          thumbnail = Asset.sprites.futurist_character_full,
          background = Asset.sprites.card_effect_target_enriched,
        },
        starter = {
          deck = require("vibes.character.default-deck")[CharacterKind.FUTURIST](),
          energy = 0,
          gold = 0,
        },
      },
    },
    player = Player.new {
      health = Config.player.default_health,
      max_health = Config.player.default_health,
      energy = Config.player.default_energy,
      discards = Config.player.default_discards,
      hand_size = Config.player.default_hand_size,
      gold = Config.player.starting_gold,
      block = Config.player.default_block,
    },
    total_damage_dealt = 0,
    total_enemy_health_removed = 0,
    mouse_object = Mouse.new(),
    start_time = love.timer.getTime(),
    focused_text_box = nil,
    mode = Config.starting_mode,
    last_mode = Config.starting_mode,
    levels = require("vibes.level.manager").new {
      starting_level = Config.starting_level,
      available_levels = Config.selected_levels,
      test_wave = Config.test_wave,
      test_level = Config.test_level,
    },
    selected_character = Config.starting_character,
    debug = false,
    deck = require("vibes.character.default-deck")[Config.starting_character](),
    auras = {},
    animating_cards = {},
    projectiles = {},
    scale = 1,
    enemies = {},
    towers = {},
    gear_manager = require("gear.manager").new {},
    returning_from_shop = false,
    last_interest_earned = 0,
    interest_calculated = false,
    last_press_your_luck_rarity = nil,
    mouse = Position.new(0, 0),
    profile = false,
    surprise_mode = false,
    spawner = require("vibes.enemy.spawn-manager").new(),
    edges = {},
    callbacks = {},
    game_speed = 1,

    -- Base weights for calculating card rarity
    kind_weights = {
      { kind = CardKind.TOWER, weight = 0.20 },
      { kind = CardKind.ENHANCEMENT, weight = 0.60 },
      { kind = CardKind.AURA, weight = 0.20 },
    },

    card_rarity = {
      [CardKind.TOWER] = {
        { kind = Rarity.COMMON, weight = 0.50 },
        { kind = Rarity.UNCOMMON, weight = 0.25 },
        { kind = Rarity.RARE, weight = 0.20 },
        { kind = Rarity.EPIC, weight = 0.04 },
        { kind = Rarity.LEGENDARY, weight = 0.01 },
      },
      [CardKind.ENHANCEMENT] = {
        { kind = Rarity.COMMON, weight = 0.50 },
        { kind = Rarity.UNCOMMON, weight = 0.25 },
        { kind = Rarity.RARE, weight = 0.20 },
        { kind = Rarity.EPIC, weight = 0.04 },
        { kind = Rarity.LEGENDARY, weight = 0.01 },
      },
      [CardKind.AURA] = {
        { kind = Rarity.COMMON, weight = 0.50 },
        { kind = Rarity.UNCOMMON, weight = 0.25 },
        { kind = Rarity.RARE, weight = 0.20 },
        { kind = Rarity.EPIC, weight = 0.04 },
        { kind = Rarity.LEGENDARY, weight = 0.01 },
      },
    },

    tower_upgrade_weights = {
      { kind = Rarity.COMMON, weight = 0.50 },
      { kind = Rarity.UNCOMMON, weight = 0.25 },
      { kind = Rarity.RARE, weight = 0.20 },
      { kind = Rarity.EPIC, weight = 0.04 },
      { kind = Rarity.LEGENDARY, weight = 0.01 },
    },

    enhancement_target_towers = {},

    card_costs = {
      [CardKind.TOWER] = {
        [Rarity.COMMON] = 200, -- Doubled from 100
        [Rarity.UNCOMMON] = 450, -- Doubled from 225
        [Rarity.RARE] = 700, -- Doubled from 350
        [Rarity.EPIC] = 1000, -- Doubled from 500
        [Rarity.LEGENDARY] = 1600, -- Doubled from 800
      },
    },
  }

  --- @TODO why do we have extra values here?  The health bar and such
  --- @diagnostic disable-next-line
  local instance = setmetatable(values, GameState) --[[@type vibes.GameState]]
  instance:update_edges()

  SoundManager:init_common_pools()

  return instance
end

function GameState:update_edges()
  local width, height = love.graphics.getDimensions()
  self.edges.top = {
    left = Position.new(0, 0),
    center = Position.new(width / 2, 0),
    right = Position.new(width, 0),
  }
  self.edges.right = {
    top = Position.new(width, 0),
    middle = Position.new(width, height / 2),
    bottom = Position.new(width, height),
  }
  self.edges.bottom = {
    left = Position.new(0, height),
    center = Position.new(width / 2, height),
    right = Position.new(width, height),
  }
  self.edges.left = {
    top = Position.new(0, 0),
    middle = Position.new(0, height / 2),
    bottom = Position.new(0, height),
  }
  self.edges.middle = Position.new(width / 2, height / 2)
end

---@param dt number
function GameState:update(dt)
  self:update_edges()
  for i = #self.callbacks, 1, -1 do
    local callback = self.callbacks[i]
    callback.time_remaining = callback.time_remaining - dt
    if callback.time_remaining <= 0 then
      -- Execute callback and remove it
      callback.cb()
      table.remove(self.callbacks, i)
    end
  end
end

---@param cb fun(): nil
---@param time_remaining number
function GameState:add_callback(cb, time_remaining)
  table.insert(self.callbacks, {
    cb = cb,
    time_remaining = time_remaining,
  })
end

--- Trigger the game over screen and display the wave of death
function GameState:trigger_game_over()
  logger.debug("Game Over on:" .. self.levels.current_level_idx)
  self.game_results = {
    status = "loss",
  }
  ActionQueue:add(GameOverAction.new {})
end

function GameState:get_mode() return assert(MODES[self.mode]) end

function GameState:remove_enemy(enemy)
  for i, state_enemy in ipairs(self.enemies) do
    if state_enemy.id == enemy.id then
      table.remove(self.enemies, i)
      break
    end
  end
end

--- Calculate modified energy cost for a card with gear effects
---@param card vibes.Card
---@return number modified_cost
function GameState:get_modified_energy_cost(card)
  ---@type hooks.OnCardInfoResult
  local result = {
    card = card,
    modified_energy = card.energy,
  }

  State:for_each_active_hook(
    function(item) item.hooks.on_card_info(item, result) end
  )

  return math.max(0, result.modified_energy)
end

function GameState:play_aura_card(aura)
  local energy_cost = self:get_modified_energy_cost(aura)
  if not State.player:use_energy(energy_cost) then
    return false, "If you are a user seeing this, tweet @ThePrimeagen"
  end

  self:add_aura(aura)

  State.deck:handle_card_after_play(aura)
  State:play_card_hooks(aura)

  return true
end

---@param opts { tower_card: vibes.TowerCard, cell: vibes.Cell }
function GameState:play_tower_card(opts)
  local TowerCard = require "vibes.card.base-tower-card"

  validate(opts, {
    tower_card = TowerCard,
    cell = Cell,
  })

  local tower_card = opts.tower_card
  local tower = tower_card.tower
  local cell = opts.cell

  local energy_cost = self:get_modified_energy_cost(tower_card)
  if not State.player:use_energy(energy_cost) then
    return false, "If you are a user seeing this, tweet @ThePrimeagen"
  end

  if not tower:can_place(cell) then
    return false, "Tower cannot be placed here!"
  end

  cell.is_placeable = false

  tower:place(cell)

  -- Link the tower back to its source tower card
  tower.source_tower_card = tower_card

  table.insert(State.towers, tower)

  -- Apply any preserved enhancements from this specific tower card
  local preserved_enhancements = tower_card:get_preserved_enhancements()
  for _, enhancement in ipairs(preserved_enhancements) do
    tower:add_enhancement(enhancement)
  end

  State.deck:handle_card_after_play(tower_card)
  State:play_card_hooks(tower_card)

  EventBus:emit_tower_placed { tower = tower_card }

  return true
end

---@param enhancement vibes.EnhancementCard
---@param tower components.PlacedTower
---@return boolean success Was the card successfully played?
---@return string? error_message Error message if the card was not successfully played
function GameState:play_enhancement_card(enhancement, tower)
  local energy_cost = self:get_modified_energy_cost(enhancement)
  if State.player.energy < energy_cost then
    return false, "Not enough energy"
  end

  if not tower then
    return false, "You must select a tower to enhance!"
  end

  if not tower.tower:has_free_card_slot() then
    return false, "No available slots on Tower!"
  end

  State.player:use_energy(energy_cost)
  State.deck:handle_card_after_play(enhancement)

  -- Store target tower for immediate hook access
  self.enhancement_target_towers[enhancement] = tower

  tower.tower:add_enhancement(enhancement)

  State:play_card_hooks(enhancement)

  -- Clean up the target tower reference
  self.enhancement_target_towers[enhancement] = nil

  return true
end

--- @param selected_card vibes.Card
function GameState:play_card_hooks(selected_card)
  EventBus:emit_card_played { card = selected_card }

  -- Check if this is an effect card and call its play method
  local effect_card = selected_card --[[@as vibes.EffectCard?]]
  if effect_card and effect_card.play_effect_card then
    effect_card:play_effect_card()
  end

  for _, effect in ipairs(self.auras) do
    if effect.hooks and effect.hooks.on_card_played then
      effect.hooks.on_card_played(effect, selected_card)
    end
  end

  State.gear_manager:for_gear_in_active_gear(function(gear)
    if gear.hooks and gear.hooks.on_card_played then
      gear.hooks.on_card_played(gear, selected_card)
    end
  end)

  for _, tower in ipairs(self.towers) do
    if tower.hooks and tower.hooks.on_card_played then
      tower.hooks.on_card_played(tower, selected_card)
    end
  end
end

---@param aura vibes.AuraCard
function GameState:add_aura(aura)
  validate({ aura = aura }, { aura = AuraCard })
  table.insert(self.auras, aura)
end

function GameState:get_character_sprite()
  if self.selected_character == CharacterKind.BLACKSMITH then
    return Asset.sprites.blacksmith_character_card
  elseif self.selected_character == CharacterKind.MAGE then
    return Asset.sprites.mage_character_card
  elseif self.selected_character == CharacterKind.FUTURIST then
    return Asset.sprites.futurist_character_card
  else
    error("unhandled character: " .. self.selected_character)
  end
end

---@class state.DamageEnemyOpts
---@field enemy vibes.Enemy
---@field source? vibes.Tower
---@field damage number
---@field kind DamageKind

---@param opts state.DamageEnemyOpts
---@return { shield_damage: number, health_damage: number }
local get_effective_damage_after_shield = function(opts)
  local enemy = opts.enemy
  local damage = opts.damage

  -- Physical and Fire attacks reduce and attack shield
  if
    opts.kind == DamageKind.PHYSICAL
    or opts.kind == DamageKind.FIRE
    or opts.kind == DamageKind.ORC_WHEELER_EXPLOSION
  then
    local shield = enemy:get_shield()
    local block = enemy:get_block()
    if opts.kind == DamageKind.FIRE then
      block = 0
    end
    if enemy.statuses.wet then
      block = 0
    end

    if block > 0 then
      EventBus:emit_enemy_blocked_damage {
        enemy = enemy,
        blocked = block,
      }
    end

    damage = math.max(0, damage - block)
    if damage == 0 then
      return {
        shield_damage = 0,
        health_damage = 0,
      }
    end

    if shield >= damage then
      return {
        shield_damage = damage,
        health_damage = 0,
      }
    else
      return {
        shield_damage = shield,
        health_damage = damage - shield,
      }
    end
  end

  if opts.kind == DamageKind.POISON then
    return {
      shield_damage = 0,
      health_damage = damage,
    }
  end

  if opts.kind == DamageKind.WATER then
    local block = enemy:get_block()
    if block > 0 then
      EventBus:emit_enemy_blocked_damage {
        enemy = enemy,
        blocked = block,
      }
    end

    damage = damage - block
    return {
      shield_damage = 0,
      health_damage = damage,
    }
  end

  error("unhandled damage kind: " .. opts.kind)
end

---@param opts state.DamageEnemyOpts
function GameState:damage_enemy(opts)
  local enemy = opts.enemy
  local enemy_position = enemy.position

  -- Apply critical damage for physical attacks before shield calculation
  local final_damage = opts.damage
  local crits_triggered = 0

  if opts.kind == DamageKind.PHYSICAL and opts.source then
    local CriticalDamage = require "vibes.data.critical-damage"
    local critical_chance = opts.source:get_critical()
    local critical_result =
      CriticalDamage.calculate_critical_damage(opts.damage, critical_chance)

    final_damage = critical_result.damage
    crits_triggered = critical_result.crits_triggered

    if State.gear_manager:has_gear(GEAR.moustache_comb) then
      final_damage = final_damage * 1.5
    end

    -- Emit critical hit event if any crits occurred
    if crits_triggered > 0 then
      EventBus:emit_tower_critical_hit {
        tower = opts.source,
        enemy = enemy,
        base_damage = opts.damage,
        critical_damage = final_damage,
        crits_triggered = crits_triggered,
      }
    end
  end

  -- Check for Live Fast Die Young enhancement and apply speed-based damage bonus
  -- TODO(TJ): Would be quite a bit nicer to pull this into a stat for enemies, just one that we don't display.
  if opts.source then
    local LiveFastDieYoung =
      require "vibes.card.enhancement.live-fast-die-young"

    for _, enhancement in ipairs(opts.source.enhancements) do
      if LiveFastDieYoung.is(enhancement) then
        ---@cast enhancement enhancement.LiveFastDieYoung

        local enemy_speed = enemy:get_speed()
        local speed_multiplier = enhancement:_get_speed_multiplier(enemy_speed)
        local speed_bonus_damage = final_damage * (speed_multiplier - 1)

        if speed_bonus_damage > 0 then
          final_damage = final_damage + speed_bonus_damage
          logger.info(
            "Live Fast Die Young: Applied speed bonus damage %.1f (speed: %.1f, multiplier: %.2f)",
            speed_bonus_damage,
            enemy_speed,
            speed_multiplier
          )
        end
        break -- Only apply once even if multiple Live Fast Die Young cards
      end
    end
  end

  -- Check for Water Pollution gear and apply damage multiplier to orcas
  if State.gear_manager:has_gear(GEAR.water_pollution) then
    if enemy.enemy_type == EnemyType.ORCA then
      final_damage = final_damage * 9.0 -- 8x multiplier (1 + 8 = 9x total)
    end
  end

  -- Use the critical-modified damage for shield calculation
  local modified_opts = {
    enemy = enemy,
    source = opts.source,
    damage = final_damage,
    kind = opts.kind,
  }
  local damage = get_effective_damage_after_shield(modified_opts)

  local starting_health = enemy.health
  if opts.kind == DamageKind.PHYSICAL then
    if opts.source then
      opts.source:apply_experience_for_damage(
        math.min(damage.health_damage, starting_health)
      )
    end
  elseif opts.kind == DamageKind.WATER then
    if opts.source then
      opts.source:apply_experience_for_damage(
        math.min(damage.health_damage, starting_health)
      )
    end
  elseif opts.kind == DamageKind.POISON then
    local total_sources = 0
    for _, tower_damage in pairs(enemy.poison_stack_sources) do
      total_sources = total_sources + tower_damage
    end

    -- Cap the total XP-eligible damage to what was actually dealt
    local xp_eligible_damage = math.min(damage.health_damage, starting_health)

    for tower, tower_damage in pairs(enemy.poison_stack_sources) do
      tower:apply_experience_for_damage(
        xp_eligible_damage * tower_damage / total_sources
      )
    end
  elseif opts.kind == DamageKind.FIRE then
    local total_sources = 0
    for _, tower_damage in pairs(enemy.fire_stack_sources) do
      total_sources = total_sources + tower_damage
    end

    -- Cap the total XP-eligible damage to what was actually dealt
    local xp_eligible_damage = math.min(damage.health_damage, starting_health)

    for tower, tower_damage in pairs(enemy.fire_stack_sources) do
      tower:apply_experience_for_damage(
        xp_eligible_damage * tower_damage / total_sources
      )
    end
  end

  -- TODO: Show enemy being hit by damage, used to be `hit_flash = true`
  if damage.shield_damage > 0 then
    enemy:set_shield(enemy:get_shield() - damage.shield_damage)
  end

  if damage.health_damage > 0 then
    --- This makes the total damage calculated in the UI match the damage done
    --to units instead of total damage of tower
    damage.health_damage = math.min(damage.health_damage, enemy.health)
    enemy.health = math.max(0, enemy.health - damage.health_damage)
  end

  EventBus:emit_enemy_damage {
    enemy = opts.enemy,
    tower = opts.source,
    damage = damage.health_damage,
    kind = opts.kind,
  }

  if enemy.health <= 0 then
    EventBus:emit_enemy_death {
      enemy = enemy,
      tower = opts.source,
      position = enemy_position,
      kind = opts.kind,
    }

    for _, tower in ipairs(State.towers) do
      if tower.hooks and tower.hooks.after_enemy_death then
        tower.hooks.after_enemy_death(tower, enemy)
      end
    end
  end
end

---@param block number
function GameState:give_player_block(block) self.player:gain_block(block) end

---@param block number
---@return boolean Whether the block was successfully used
function GameState:use_player_block(block) return self.player:use_block(block) end

---@param damage number
function GameState:damage_player(damage) self.player:take_damage(damage) end

---@param damage number
function GameState:damage_player_health(damage)
  self.player:damage_health(damage)
end

---@return components.PlacedTower?
function GameState:get_placed_tower_at_mouse()
  local PlacedTower = require "ui.components.tower.placed-tower"
  for _, el in ipairs(GAME.ui.enemy_tower_children.children) do
    if
      el:contains_absolute_x_y(self.mouse.x, self.mouse.y)
      and PlacedTower.is(el)
    then
      return el --[[@as components.PlacedTower]]
    end
  end
  return nil
end

local tower_upgrade_random = Random.new {
  name = "TowerUpgradeOptions",
}

---@param tower vibes.Tower
---@return tower.UpgradeOption[]
function GameState:get_tower_upgrade_options(tower)
  local options = tower:get_upgrade_options()
  local weights = self.tower_upgrade_weights

  ---@type tower.UpgradeOption[]
  local upgrades = {}
  local seen = {}
  local count = 0

  local total_unique_options = 0
  local unique = {}
  for _, list in pairs(options) do
    ---@cast list tower.UpgradeOption[]
    for _, option in ipairs(list) do
      ---@cast option tower.UpgradeOption
      if not unique[option.name] then
        unique[option.name] = true
        total_unique_options = total_unique_options + 1
      end
    end
  end

  -- Don't try to get more options than are available
  local target_count =
    math.min(self.tower_upgrade_options_count, total_unique_options)

  while #upgrades < target_count and count < Config.max_loop_count do
    count = count + 1
    local roll = tower_upgrade_random:random()
    local rarity = pick_based_on_roll(roll, weights)

    ---@type tower.UpgradeOption[]
    local pool = options[rarity]
    if not pool or #pool == 0 then
      local fallback = {}
      if rarity == Rarity.LEGENDARY then
        fallback = { Rarity.RARE, Rarity.UNCOMMON, Rarity.COMMON }
      elseif rarity == Rarity.EPIC then
        fallback = { Rarity.RARE, Rarity.UNCOMMON, Rarity.COMMON }
      elseif rarity == Rarity.RARE then
        fallback = { Rarity.UNCOMMON, Rarity.COMMON }
      elseif rarity == Rarity.UNCOMMON then
        fallback = { Rarity.COMMON }
      elseif rarity == Rarity.COMMON then
        fallback = { Rarity.UNCOMMON, Rarity.RARE }
      end

      for _, r in ipairs(fallback) do
        if options[r] and #options[r] > 0 then
          pool = options[r]
          break
        end
      end

      if not pool then
        for _, list in pairs(options) do
          if type(list) == "table" and #list > 0 then
            pool = list
            break
          end
        end
      end
    end

    local upgrade_option = nil
    if pool then
      upgrade_option = tower_upgrade_random:of_list(pool)
    end

    if upgrade_option and not seen[upgrade_option.name] then
      table.insert(upgrades, upgrade_option)
      seen[upgrade_option.name] = true
    end

    if not upgrade_option or total_unique_options == #upgrades then
      break
    end
  end

  if count >= Config.max_loop_count then
    logger.warn "Max loop count reached -- fix yo while loop"
    return upgrades
  end

  return upgrades
end

---@param fn fun(item: { hooks: vibes.Hooks })
---@param filters? { all_cards: boolean }
function GameState:for_each_active_hook(fn, filters)
  filters = filters or {}
  filters.all_cards = F.if_nil(filters.all_cards, false)

  local hooks = {}

  -- Hooks for level?
  -- for _, enhancement in ipairs(self.levels:get_current_level().enhancements) do
  --   table.insert(hooks, enhancement)
  -- end

  State.gear_manager:for_gear_in_active_gear(fn)

  for _, aura in ipairs(self.auras) do
    fn(aura)
  end

  for _, tower in ipairs(self.towers) do
    if tower.hooks then
      fn(tower)
    end

    for _, enhancement in ipairs(tower.enhancements) do
      if enhancement.hooks then
        fn(enhancement)
      end
    end
  end

  if filters.all_cards then
    for _, card in ipairs(self.deck:get_all_cards()) do
      if card.hooks then
        fn(card)
      end
    end
  end

  return hooks
end

return GameState
